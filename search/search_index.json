{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Main file to see here","text":"<p>Without this file the website does not start</p>"},{"location":"programming/DOTNET/Access%20Modifiers/","title":"Access Modifiers","text":"<p>All types and type members have an accessibility level. The accessibility level controls whether they can be used from other code in your assembly or other assemblies. </p> <ul> <li>public: Code in any assembly can access this type or member. The accessibility level of the containing type controls the accessibility level of public members of the type.</li> <li>private: Only code declared in the same <code>class</code> or <code>struct</code> can access this member.</li> <li>protected: Only code in the same <code>class</code> or in a derived <code>class</code> can access this type or member.</li> <li>internal: Only code in the same assembly can access this type or member.</li> <li>protected internal: Only code in the same assembly or in a derived class in another assembly can access this type or member.</li> <li>private protected: Only code in the same assembly and in the same class or a derived class can access the type or member.</li> <li>file: Only code in the same file can access the type or member.</li> </ul> <p>The record modifier on a type causes the compiler to synthesize extra members. The <code>record</code> modifier doesn't affect the default accessibility for either a <code>record class</code> or a <code>record struct</code>.</p>","tags":["programming","dotnet"]},{"location":"programming/DOTNET/Access%20Modifiers/#summary-table","title":"Summary table","text":"Caller's location <code>public</code> <code>protected internal</code> <code>protected</code> <code>internal</code> <code>private protected</code> <code>private</code> <code>file</code> Within the file \u2714\ufe0f\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f Within the class \u2714\ufe0f\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u274c Derived class (same assembly) \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u274c \u274c Non-derived class (same assembly) \u2714\ufe0f \u2714\ufe0f \u274c \u2714\ufe0f \u274c \u274c \u274c Derived class (different assembly) \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u274c \u274c \u274c \u274c Non-derived class (different assembly) \u2714\ufe0f \u274c \u274c \u274c \u274c \u274c \u274c","tags":["programming","dotnet"]},{"location":"programming/DOTNET/Accessibility%20Levels/","title":"Accessibility Levels","text":"<p>Use the access modifiers, <code>public</code>, <code>protected</code>, <code>internal</code>, or <code>private</code>, to specify one of the following declared accessibility levels for members.</p> Declared accessibility Meaning public Access is not restricted. protected Access is limited to the containing class or types derived from the containing class. internal Access is limited to the current assembly. protected internal Access is limited to the current assembly or types derived from the containing class. private Access is limited to the containing type. private protected Access is limited to the containing class or types derived from the containing class within the current assembly. <p>Only one access modifier is allowed for a member or type, except when you use the <code>protected internal</code> or <code>private protected</code> combinations.</p> <p>Access modifiers are not allowed on namespaces. Namespaces have no access restrictions.</p> <p>Depending on the context in which a member declaration occurs, only certain declared accessibilities are permitted. If no access modifier is specified in a member declaration, a default accessibility is used.</p> <p>Top-level types, which are not nested in other types, can only have <code>internal</code> or <code>public</code> accessibility. The default accessibility for these types is <code>internal</code>.</p> <p>Nested types, which are members of other types, can have declared accessibilities as indicated in the following table.</p> Members of Default member accessibility Allowed declared accessibility of the member <code>enum</code> <code>public</code> None <code>class</code> <code>private</code> <code>public</code> <code>protected</code> <code>internal</code> <code>private</code> <code>protected internal</code> <code>private protected</code> <code>interface</code> <code>public</code> <code>public</code> <code>protected</code> <code>internal</code> <code>private</code>*   <code>protected internal</code> <code>private protected</code> <code>struct</code> <code>private</code> <code>public</code> <code>internal</code> <code>private</code> <ul> <li>An <code>interface</code> member with <code>private</code> accessibility must have a default implementation.</li> </ul> <p>[!Note] If a class or struct is modified with the record keyword modifier, then the same access modifiers are allowed. Also, with the record modifier the default member accessibility is still <code>private</code> both for class and the struct.</p> <p>The accessibility of a nested type depends on its accessibility domain, which is determined by both the declared accessibility of the member and the accessibility domain of the immediately containing type. However, the accessibility domain of a nested type cannot exceed that of the containing type.</p>","tags":["programming","dotnet"]},{"location":"programming/DOTNET/DOTNET/","title":"DOTNET","text":"<ul> <li>Access Modifiers</li> <li>Accessibility Levels<ul> <li>public</li> <li>private</li> <li>protected</li> <li>internal</li> <li>protected internal</li> <li>private protected</li> <li>record</li> </ul> </li> </ul>","tags":["programming","dotnet"]},{"location":"programming/DOTNET/internal/","title":"Definition","text":"<p>The <code>internal</code> keyword is an Access Modifiers for types and type members <pre><code>class SampleClass\n{\n    internal int x;\n}\n</code></pre> Internal types or members are accessible only within files in the same assembly</p>","tags":["programming","dotnet","OOP"]},{"location":"programming/DOTNET/internal/#usage","title":"Usage","text":"<p>A common use of internal access is in component-based development because it enables a group of components to cooperate in a private manner without being exposed to the rest of the application code.</p> <p>[!warning] It is an error to reference a type or a member with internal access outside the assembly within which it was defined.</p>","tags":["programming","dotnet","OOP"]},{"location":"programming/DOTNET/private%20protected/","title":"Private protected","text":"<p>The <code>private protected</code> keyword combination is member Access Modifiers. A private protected member is accessible by types derived from the containing class, but only within its containing assembly. </p> <p>[!note] Struct members cannot be <code>private protected</code> because the struct cannot be inherited</p>","tags":["programming","dotnet","OOP"]},{"location":"programming/DOTNET/private/","title":"Private","text":"<p>The <code>private</code> keyword is a member Access Modifiers.</p> <p>Private access is the least permissive access level. Private members are accessible only within the body of the class or the struct in which they are declared, as in this example: <pre><code>class Employee\n{\n    private int _i;\n    double _d;  \n}\n</code></pre></p> <p>[!note] Nested types in the same body can also access those private members.</p> <p>[!error] It is a compile-time error to reference a private member outside the class or the struct in which it is declared.</p>","tags":["programming","dotnet","OOP"]},{"location":"programming/DOTNET/protected%20internal/","title":"Protected internal","text":"<p>The <code>protected internal</code> keyword combination is a member Access Modifiers. A protected  internal member is accessible from the current assembly or from types that are derived from the containing class.</p> <p>[!note] Struct members cannot be <code>protected internal</code> because the struct cannot be inherited</p>","tags":["programming","dotnet","OOP"]},{"location":"programming/DOTNET/protected%20internal/#overriding-protected-internal-members","title":"Overriding protected internal members","text":"<p>When overriding a virtual member, the accessibility modifier of the overridden method depends on the assembly where the derived class is defined.</p> <p>When the derive class is define din the same assembly as the base class, all overridden members have <code>protected internal</code> access. If the derived class is defined in a different assembly from the base class, overridden member have <code>protected</code> access. </p>","tags":["programming","dotnet","OOP"]},{"location":"programming/DOTNET/protected/","title":"Protected","text":"<p>The <code>protected</code> keyword is a member access modifier. A protected member is accessible within its class and by derived class instances. <pre><code>class SampleClass{\n    protected int x;\n}\n</code></pre></p>","tags":["programming","dotnet"]},{"location":"programming/DOTNET/public/","title":"Public","text":"<p>The <code>public</code> keyword is an Access Modifiers for types and type members. Public access is the most permissive access level. There are no restrictions on accessing public members, as in this example: <pre><code>class SampleClass\n{\n    public int x;\n}\n</code></pre></p>","tags":["programming","dotnet"]},{"location":"programming/DOTNET/record/","title":"Record Modifier in C","text":"<p>The <code>record</code> modifier defines a reference type that encapsulates data. You can also use <code>record struct</code> to create similar features for value types.</p> <p>[!Note] When a primary constructor is declared on a record, the compiler generates public properties for the constructor parameters, known as positional properties. These are only synthesized when the <code>record</code> modifier is used.</p>","tags":["programming","dotnet","OOP"]},{"location":"programming/DOTNET/record/#examples","title":"Examples:","text":"<ul> <li>Reference type <code>record</code> (or <code>record class</code>): <pre><code>public record Person(string FirstName, string LastName);\n\npublic record Person\n{\n    public required string FirstName { get; init; }\n    public required string LastName { get; init; }\n};\n</code></pre></li> <li>Value type <code>record struct</code>: <pre><code>public readonly record struct Point(double X, double Y, double Z);\n\npublic record struct Point\n{\n    public double X { get; init; }\n    public double Y { get; init; }\n    public double Z { get; init; }\n}\n</code></pre></li> </ul>","tags":["programming","dotnet","OOP"]},{"location":"programming/DOTNET/record/#mutable-records","title":"Mutable Records","text":"<p>Records can also have mutable properties and fields: - Mutable <code>record</code>: <pre><code>public record Person\n{\n    public required string FirstName { get; set; }\n    public required string LastName { get; set; }\n};\n</code></pre> - Mutable <code>record struct</code>: <pre><code>public record struct DataMeasurement(DateTime TakenAt, double Measurement);\n\npublic record struct Point\n{\n    public double X { get; set; }\n    public double Y { get; set; }\n    public double Z { get; set; }\n}\n</code></pre></p>","tags":["programming","dotnet","OOP"]},{"location":"programming/DOTNET/record/#key-features-of-records","title":"Key Features of Records","text":"<ul> <li>Positional Property Definition: Easy syntax for defining properties.</li> <li>Value Equality: Equality in record types is based on the values of their properties, though for reference-type properties, equality is determined by reference identity rather than the actual contents of the reference.</li> <li>record#Nondestructive mutation: Create modified copies of records without changing the original.</li> <li>Display Formatting: Built-in formatting for better display in debugging or logs.</li> <li>Inheritance Support: Records can be part of inheritance hierarchies.</li> </ul>","tags":["programming","dotnet","OOP"]},{"location":"programming/DOTNET/record/#reference-vs-value-types","title":"Reference vs. Value Types","text":"<ul> <li><code>record</code> or <code>record class</code> creates reference types. The <code>class</code> keyword is optional.</li> <li><code>record struct</code> creates value types.</li> <li>Positional properties are immutable in <code>record class</code> and <code>readonly record struct</code>, but mutable in <code>record struct</code>.</li> </ul>","tags":["programming","dotnet","OOP"]},{"location":"programming/DOTNET/record/#positional-syntax-for-property-definition","title":"Positional syntax for property definition","text":"<p>You can declare properties using positional parameters and initialize them when creating an instance:</p> <pre><code>public record Person(string FirstName, string LastName);\n\npublic static void Main()\n{\n    Person person = new(\"Nancy\", \"Davolio\");\n    Console.WriteLine(person);\n    // output: Person { FirstName = Nancy, LastName = Davolio }\n}\n</code></pre>","tags":["programming","dotnet","OOP"]},{"location":"programming/DOTNET/record/#compiler-generated-features","title":"Compiler-Generated Features:","text":"<ul> <li>Public auto-implemented properties:<ul> <li><code>init-only</code> for <code>record</code> and <code>readonly record struct</code>.</li> <li>Read-write for <code>record struct</code>.</li> </ul> </li> <li>Primary constructor matching the positional parameters.</li> <li>Parameterless constructor for <code>record struct</code>, initializing fields to default values.</li> <li><code>Deconstruct</code> method for extracting positional parameters.</li> </ul> <p>You can apply attributes to these properties using the <code>property:</code>, <code>field:</code>, or <code>param:</code> targets: <pre><code>public record Person([property: JsonPropertyName(\"firstName\")] string FirstName, \n    [property: JsonPropertyName(\"lastName\")] string LastName);\n</code></pre> If the auto-implemented property isn't what you need, you can define your own property and adjust its accessibility or mutability: <pre><code>public record Person(string FirstName, string LastName, string Id)\n{\n    internal string Id { get; init; } = Id;\n}\n\npublic static void Main()\n{\n    Person person = new(\"Nancy\", \"Davolio\", \"12345\");\n    Console.WriteLine(person.FirstName); //output: Nancy\n}\n</code></pre> A record can also include additional fields or properties: <pre><code>public record Person(string FirstName, string LastName)\n{\n    public string[] PhoneNumbers { get; init; } = [];\n};\n</code></pre></p>","tags":["programming","dotnet","OOP"]},{"location":"programming/DOTNET/record/#immutability","title":"Immutability","text":"<ul> <li>Positional records and readonly record structs declare <code>init-only</code> properties.</li> <li>Positional record structs declare read-write properties, though you can override these defaults.</li> </ul> <p>Immutability is useful for thread safety and hash codes but may not suit all use cases (e.g., Entity Framework Core doesn't support immutable entity types).</p> <p>Init-only properties are shallowly immutable\u2014after initialization, you can't change the property itself, but the data it references can be modified: <pre><code>public record Person(string FirstName, string LastName, string[] PhoneNumbers);\n\npublic static void Main()\n{\n    Person person = new(\"Nancy\", \"Davolio\", new string[1] { \"555-1234\" });\n    Console.WriteLine(person.PhoneNumbers[0]); // output: 555-1234\n\n    person.PhoneNumbers[0] = \"555-6789\";\n    Console.WriteLine(person.PhoneNumbers[0]); // output: 555-6789\n}\n</code></pre></p> <p>Records achieve immutability through compiler-synthesized methods, without modifying object state unless explicitly defined otherwise.</p>","tags":["programming","dotnet","OOP"]},{"location":"programming/DOTNET/record/#nondestructive-mutation","title":"Nondestructive mutation","text":"<p>Records in C# support nondestructive mutation using the <code>with</code> expression. This allows you to create a copy of an existing record instance with certain properties modified, without affecting the original instance.</p> <p>For example: <pre><code>public record Person(string FirstName, string LastName)\n{\n    public string[] PhoneNumbers { get; init; }\n}\n\npublic static void Main()\n{\n    Person person1 = new(\"Nancy\", \"Davolio\") { PhoneNumbers = new string[1] };\n    Console.WriteLine(person1);\n    // output: Person { FirstName = Nancy, LastName = Davolio, PhoneNumbers = System.String[] }\n\n    Person person2 = person1 with { FirstName = \"John\" };\n    Console.WriteLine(person2);\n    // output: Person { FirstName = John, LastName = Davolio, PhoneNumbers = System.String[] }\n    Console.WriteLine(person1 == person2); // output: False\n\n    person2 = person1 with { PhoneNumbers = new string[1] };\n    Console.WriteLine(person2);\n    // output: Person { FirstName = Nancy, LastName = Davolio, PhoneNumbers = System.String[] }\n    Console.WriteLine(person1 == person2); // output: False\n\n    person2 = person1 with { };\n    Console.WriteLine(person1 == person2); // output: True\n}\n</code></pre></p> <p>The <code>with</code> expression creates a shallow copy of the original instance. If a record has reference-type properties, the reference is copied, not the actual object it points to. This means that both the original and the copied instance share the same reference to the object.</p> <p>In the case of a <code>record class</code>, the compiler synthesizes the following methods to support nondestructive mutation:</p> <ul> <li>A clone method: This method creates a new instance and is invoked by the <code>with</code> expression.</li> <li>A copy constructor: This constructor initializes the new instance with the same values as the original instance, except for properties modified by the <code>with</code> expression.</li> </ul> <p>The clone method cannot be overridden, and you cannot define a member named <code>Clone</code> in any record type.</p> <p>If you need different copying behavior, you can define your own copy constructor. If you do, the compiler will not generate one. For sealed records, the constructor should be <code>private</code>; for others, it should be <code>protected</code>.</p>","tags":["programming","dotnet","OOP"]}]}